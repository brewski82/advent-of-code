(defpackage #:advent-2024-day-13
  (:use #:common-lisp #:alexandria #:cl-ppcre)
  (:import-from #:metabang-bind #:bind)
  (:import-from #:serapeum #:append1 #:~>> #:~> #:batches)
  (:import-from #:nclasses #:define-class)
  (:import-from #:access #:access #:accesses #:set-access)
  (:import-from #:array-operations/utilities #:nested-loop))

(in-package #:advent-2024-day-13)

(defun day-13 ()
  (~>> (uiop:read-file-lines "~/Downloads/input-13")
       (parse-machines)
       (mapcar #'parse-machine)
       (mapcar (curry #'apply #'solve))
       (remove-if #'null)
       (reduce #'+)))

(defun parse-machines (lines)
  (~>> lines
       (remove-if (compose #'zerop #'length))
       (batches _ 3)))

(defun parse-machine (machine)
  (list (parse-prize (third machine))
        (parse-button (first machine))
        (parse-button (second machine))))

(defun solve (prize a-button b-button)
  (loop with best-cost = nil
        for a-presses from 0 to 100
        for remaining-x = (- (x prize) (* (x a-button) a-presses))
        for (b-presses mod) = (multiple-value-list (truncate remaining-x (x b-button)))
        for y-axis = (+ (* (y a-button) a-presses) (* (y b-button) b-presses))
        for cost = (+ (* 3 a-presses) b-presses)
        unless (or (plusp mod)
                   (< b-presses 0)
                   (> b-presses 100)
                   (/= y-axis (y prize)))
          do (setf best-cost (min cost (or best-cost cost)))
        finally (return best-cost)))

(defun parse-button (line)
  (cl-ppcre:register-groups-bind ((#'parse-integer x) (#'parse-integer y))
      ("X\\+(\\d+), Y\\+(\\d+)" line)
    (cons x y)))

(defun parse-prize (line)
  (cl-ppcre:register-groups-bind ((#'parse-integer x) (#'parse-integer y))
      ("X=(\\d+), Y=(\\d+)" line)
    (cons x y)))

(defun day-13-part-2 ()
  (~>> (uiop:read-file-lines "~/Downloads/input-13")
       (parse-machines)
       (mapcar #'parse-machine)
       (mapcar #'adjust-prize)
       (mapcar (curry #'apply #'solve-2))
       (remove-if #'null)
       (reduce #'+)))


(defun adjust-prize (machine)
  (bind (((prize a b) machine))
    (list (cons (+ 10000000000000 (x prize))
                (+ 10000000000000 (y prize)))
          a
          b)))

;;; Thanks o1 mini!!
(defun solve-2 (prize a-button b-button)
  (bind ((determinate (- (* (x a-button) (y b-button))
                         (* (x b-button) (y a-button)))))
    (if (zerop determinate)
        (progn (when (or (/= (* (x a-button) (y prize))
                             (* (y a-button) (x prize)))
                         (/= (* (x b-button) (y prize))
                             (* (y b-button) (x prize))))
                 (return-from solve-2 nil))
               (bind ((max-b (if (zerop (x b-button))
                                 0
                                 (/ (x prize)
                                    (x b-button)))))
                 (loop with min-cost = nil
                       for b-presses from 0 to max-b
                       for a-presses = (/ (- (x prize)
                                             (* (x b-button) b-presses))
                                          (x a-button))
                       for cost = (+ (* 3 a-presses) b-presses)
                       unless (or (/= 0 (mod (- (x prize)
                                                (* (x b-button)
                                                   b-presses))
                                             (x a-button)))
                                  (< a-presses 0)
                                  (/= (y prize)
                                      (+ (* (y a-button) a-presses)
                                         (* (y b-button) b-presses))))
                         do (setf min-cost (min cost (or min-cost cost)))
                       finally (return min-cost))))
        (bind ((a-presses (- (* (x prize)
                                (y b-button))
                             (* (y prize)
                                (x b-button))))
               (b-presses (- (* (x a-button)
                                (y prize))
                             (* (y a-button)
                                (x prize)))))
          (when (and (< determinate 0)
                     (or (plusp a-presses)
                         (plusp b-presses)))
            (setf a-presses (* -1 a-presses)
                  b-presses (* -1 b-presses)
                  determinate (* -1 determinate)))
          (when (or (/= 0 (mod a-presses determinate))
                    (/= 0 (mod b-presses determinate)))
            (return-from solve-2))
          (setf a-presses (/ a-presses determinate)
                b-presses (/ b-presses determinate))
          (if (or (< a-presses 0)
                  (< b-presses 0))
              nil
              (+ (* 3 a-presses) b-presses))))))

(defun x (coordinate)
  (car coordinate))

(defun y (coordinate)
  (cdr coordinate))
